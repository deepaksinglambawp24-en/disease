# -*- coding: utf-8 -*-
"""Untitled42.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14PUHO9QHUuBljbaJzkm4uMPEKSWL648X
"""

import streamlit as st
import joblib
import pandas as pd
import numpy as np
import sklearn
# Importing the module where the missing class is expected to be
from sklearn.compose import _column_transformer

# --- ‚ö†Ô∏è Workaround for '_RemainderColsList' Error ‚ö†Ô∏è ---
# This attempts to define the missing class dynamically.
try:
    if not hasattr(_column_transformer, '_RemainderColsList'):
        class _RemainderColsList(list):
            """Placeholder class to satisfy joblib pickling from slightly different scikit-learn versions."""
            pass
        # Define it directly on the module
        _column_transformer._RemainderColsList = _RemainderColsList
        st.info("Applying dynamic fix for scikit-learn unpickling issue.")
except Exception:
    pass # Continue if the fix itself fails to apply


# --- Model Configuration ---
NUM_FEATURES = ['temperature', 'humidity', 'rainfall', 'soil_pH']
CAT_FEATURES = []
CLASSES = ['Disease A', 'Disease B', 'Disease C']

# --- Model Loading Function ---

@st.cache_resource
def load_model(file_path):
    """Loads the scikit-learn pipeline using joblib."""
    try:
        pipeline = joblib.load(file_path)

        # Safely extract and set the class names
        if hasattr(pipeline.named_steps['model'], 'classes_'):
            global CLASSES
            CLASSES = pipeline.named_steps['model'].classes_.tolist()
            st.success(f"Model loaded successfully! Detected classes: {', '.join(CLASSES)}")
        else:
            st.success("Model loaded successfully!")

        return pipeline
    except Exception as e:
        st.error(f"Error loading the model: **{e}**")
        st.warning(f"FATAL: Scikit-learn version mismatch. Please ensure you are running **scikit-learn==1.6.1**.")
        st.stop()

# --- Main Streamlit Application ---

def main():
    st.set_page_config(page_title="Plant Disease Classifier")
    st.title("üå± Plant Disease Classification App")
    st.markdown(f"Using scikit-learn version **{sklearn.__version__}** to load model trained with **~1.6.1**.")
    st.markdown("Enter the environmental conditions to predict the likely plant disease.")

    # 1. Load the model
    MODEL_PATH = 'trained_model.joblib'
    model_pipeline = load_model(MODEL_PATH)

    # ... (Rest of the app remains the same for inputs and prediction)
    st.header("Environmental Inputs")

    with st.container():
        col1, col2 = st.columns(2)

        with col1:
            temperature = st.number_input(
                "Temperature (¬∞C)", min_value=0.0, max_value=50.0, value=25.0, step=0.1
            )
            rainfall = st.number_input(
                "Rainfall (mm)", min_value=0.0, max_value=1000.0, value=50.0, step=1.0
            )

        with col2:
            humidity = st.number_input(
                "Humidity (%)", min_value=0.0, max_value=100.0, value=60.0, step=0.1
            )
            soil_pH = st.number_input(
                "Soil pH", min_value=3.0, max_value=9.0, value=6.5, step=0.01
            )

    if st.button("Predict Disease"):
        input_data = pd.DataFrame([{
            'temperature': temperature, 'humidity': humidity, 'rainfall': rainfall, 'soil_pH': soil_pH,
        }])

        st.subheader("Prediction Results")

        try:
            prediction = model_pipeline.predict(input_data)[0]
            probabilities = model_pipeline.predict_proba(input_data)[0]

            predicted_class_index = np.argmax(probabilities)
            predicted_class_name = CLASSES[predicted_class_index]
            predicted_prob = probabilities[predicted_class_index]

            st.success(f"### Predicted Disease: **{predicted_class_name}**")
            st.info(f"Confidence: **{predicted_prob:.2f}**")

            st.markdown("---")
            st.write("#### All Disease Probabilities:")
            prob_df = pd.DataFrame({
                'Disease': CLASSES,
                'Probability': probabilities
            }).sort_values(by='Probability', ascending=False).reset_index(drop=True)

            st.dataframe(prob_df, use_container_width=True, hide_index=True)

        except Exception as e:
            st.error(f"An error occurred during prediction: {e}")
            st.warning("The model failed to process the input data.")

if __name__ == '__main__':
    main()