# -*- coding: utf-8 -*-
"""Untitled38.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zqmYub3lV-GyK4LYBzAf51VVFy7Xf_hX
"""

import streamlit as st
import joblib
import pandas as pd
import numpy as np

# --- Configuration based on the loaded model structure ---

# Based on the model structure, the expected numerical and categorical inputs are:
# Numerical features for SimpleImputer (median) and StandardScaler:
NUM_FEATURES = ['temperature', 'humidity', 'rainfall', 'soil_pH']  #
# Categorical features for SimpleImputer (most_frequent) and OneHotEncoder:
CAT_FEATURES = []  # No explicit categorical features found in the 'cat' step, but keeping the structure for completeness.
# The classes the model was trained on (Placeholder based on the classes_ variable)
# In a real scenario, you'd know the actual class names (e.g., 'Healthy', 'Disease A', 'Disease B')
# Based on the file structure, the classes are likely stored as a NumPy array of strings (O8 dtype)
# Let's assume a few placeholder names for the example
CLASSES = ['Disease A', 'Disease B', 'Disease C']

# --- Model Loading Function ---

@st.cache_resource
def load_model(file_path):
    """Loads the scikit-learn pipeline using joblib."""
    try:
        pipeline = joblib.load(file_path)
        st.success("Model loaded successfully!")
        return pipeline
    except Exception as e:
        st.error(f"Error loading the model: {e}")
        st.stop()

# --- Main Streamlit Application ---

def main():
    st.set_page_config(page_title="Plant Disease Classifier")
    st.title("ðŸŒ± Plant Disease Classification App")
    st.markdown("Enter the environmental conditions to predict the likely plant disease.")

    # 1. Load the model
    MODEL_PATH = 'trained_model.joblib'
    model_pipeline = load_model(MODEL_PATH)

    # Check if the model has a 'classes_' attribute and update the display names
    if hasattr(model_pipeline.named_steps['model'], 'classes_'):
        # Extract the classes from the LogisticRegression step
        # The classes_ object in the provided file suggests a NumPy array of dtype O8
        try:
            # Attempt to safely convert the classes for display
            CLASSES_FROM_MODEL = model_pipeline.named_steps['model'].classes_.tolist()
            # Ensure they are strings for display (O8 is object/string)
            if all(isinstance(c, str) for c in CLASSES_FROM_MODEL):
                global CLASSES
                CLASSES = CLASSES_FROM_MODEL
        except Exception:
            st.warning("Could not reliably extract class names from the model. Using default placeholders.")


    # 2. Input Fields for Features
    st.header("Environmental Inputs")

    # --- Numerical Inputs ---
    # The numerical features were identified as: 'temperature', 'humidity', 'rainfall', 'soil_pH'

    with st.container():
        col1, col2 = st.columns(2)

        with col1:
            temperature = st.number_input(
                "Temperature (Â°C)",
                min_value=0.0,
                max_value=50.0,
                value=25.0,
                step=0.1
            )

            rainfall = st.number_input(
                "Rainfall (mm)",
                min_value=0.0,
                max_value=1000.0,
                value=50.0,
                step=1.0
            )

        with col2:
            humidity = st.number_input(
                "Humidity (%)",
                min_value=0.0,
                max_value=100.0,
                value=60.0,
                step=0.1
            )

            soil_pH = st.number_input(
                "Soil pH",
                min_value=3.0,
                max_value=9.0,
                value=6.5,
                step=0.01
            )

    # --- Categorical Inputs (if any) ---
    # Add input fields for CAT_FEATURES here if you knew the possible categories.
    # e.g., if 'soil_type' was a categorical feature:
    # soil_type = st.selectbox("Soil Type", options=['Loam', 'Clay', 'Sand'])

    # 3. Prediction Button
    if st.button("Predict Disease"):
        # 4. Create DataFrame for Prediction
        # The DataFrame must have the same column names and order as the training data
        input_data = pd.DataFrame([{
            'temperature': temperature,
            'humidity': humidity,
            'rainfall': rainfall,
            'soil_pH': soil_pH,
            # Add other features here (like soil_type) if they exist
        }])

        st.subheader("Prediction Results")

        # 5. Make Prediction (Probability and Class)
        try:
            # Predict the class
            prediction = model_pipeline.predict(input_data)[0]

            # Predict the probabilities for all classes
            probabilities = model_pipeline.predict_proba(input_data)[0]

            # Find the most likely class and its probability
            predicted_class_index = np.argmax(probabilities)
            predicted_class_name = CLASSES[predicted_class_index]
            predicted_prob = probabilities[predicted_class_index]

            st.success(f"### Predicted Disease: **{predicted_class_name}**")
            st.info(f"Confidence: **{predicted_prob:.2f}**")

            # 6. Display all probabilities
            st.markdown("---")
            st.write("#### All Disease Probabilities:")
            prob_df = pd.DataFrame({
                'Disease': CLASSES,
                'Probability': probabilities
            }).sort_values(by='Probability', ascending=False).reset_index(drop=True)

            st.dataframe(prob_df, use_container_width=True, hide_index=True)

        except Exception as e:
            st.error(f"An error occurred during prediction: {e}")
            st.warning("Please check your input values and ensure the model file is correct.")

if __name__ == '__main__':
    main()